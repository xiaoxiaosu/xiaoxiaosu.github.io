<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PSR]]></title>
    <url>%2F2019%2F07%2F03%2FPSR%2F</url>
    <content type="text"><![CDATA[PSR是PHP Standards Recommendation的简称，是PHP-FIG制定的规范 PSR-1基本的代码风格 PHP标签 必须把PHP代码放在&lt;?php ?&gt;或&lt;?= ?&gt;标签中，不得使用其他标签语法编码 所有PHP文件都必须使用UTF-8字符集编码目的 一个PHP文件可以定义符号（类，性状，函数，常量等），或者执行有副作用的操作（生成结果，处理数据），但是不能同时做这两件事自动加载 PHP命名空间和类必须遵守PSR-4自动加载的标准类的名称 PHP类的名称必须使用驼峰式（CamelCase）常量的名称 PHP的创两必须全部使用大写，如果需要，可以用下划线把单词分开方法的名称 PHP的名称必须使用首字母小写的驼峰(camelCase) PSR-2严格的代码风格 贯彻PSR-1 使用PSR-2代码风格首先要贯彻PSR-1缩进 PSR-2要求使用4个空格缩进文件和代码行 PHP文件必须使用Unix风格的换行符，最后要有一个空行，而且不能使用PHP关闭标签?&gt;。每行代码不能超过80个字符，最多不能超过120个字符。每行末尾不能有空格关键字 PHP关键字都应该使用小写字母命名空间 每个命名空间声明行后都必须跟一个空行 在一系列use声明语句后要加一个空行类 类定义体的起始括号应该在类名之后新起一行写，类定义体的结束符号必须在定义体之后新起一行写 extends和implements关键字必须和类名写在同一行方法 方法定义体的起始括号应该在方法名之后新起一行写，方法定义体的结束符号必须在定义体之后新起一行写 方法的参数，起始的圆括号后面没有空格，结束圆括号之前也没有空格，方法的每个参数（除了最后一个）后面有一个逗号和空格 123public function hello($name = 'world', $who='xiaoming')&#123;&#125; 可见性 可见性由public，private和protected指定。 abstract和final必须放在可见性关键词之前 staic必须放在可见性关键词之后 123456class Test&#123; public $name; abstract $test; private statice $test;&#125; 控制结构 所有的控制结构关键词后面都要跟一个空格，控制解构的关键字包括：if，elseif，else，switch，case，while，do while，for，foreach，try，catch 如果控制结构关键词后面有一对括号，起始圆括号后面不能有空格，结束圆括号前面不能有空格。 控制结构后面的起始括号应该和控制关键字写在同一行。控制关键字后面的结束括号必须单独写在一行。 PSR-3日志记录器接口 符合PSR-3推荐规范的PHP日志记录器组件，必须包含一个实现Psr\Log\LoggerInter-face接口的PHP类,规定要实现九个方法 123456789101112131415&lt;?phpnamespace Psr\Log;interface LoggerInterface&#123; public function emergency($message,array $context = array()); public function alert($message,array $context = array()); public function critical($message,array $context = array()); public function error($message,array $context = array()); public function warning($message,array $context = array()); public function notice($message,array $context = array()); public function info($message,array $context = array()); public function debug($message,array $context = array()); public function log($message,array $context = array());&#125; 每个方法对应RFC 5424协议的一个日志级别，而且都接受两个参数，第一个参数$message必须是一个字符串，或者是一个有_toString()方法的对象。第二个参数是可选的，这是一个数组提供用于替换第一个参数中占位标记的值。常用的日志组件：monolog/monolog PSR-4自动加载 PSR-4描述的策略用于在运行时查找并加载PHP类，接口和性状。PSR-4推荐规范不要求来改变代码的实现方式，只建议如何使用文件系统目录结构和PHP命名空间组织代码。PSR-4自动加载器策略依赖PHP命名空间和文件系统目录结构查找并加载PHP类、接口和性状。PSR-4的精髓是把命名空间的前缀和文件系统中的目录对应起来。 12345678910111213spl_autoload_register(function ($class) &#123; $prefix = 'FOO\\Bar\\'; $baseDir = __DIR__ . '/src/'; $len = strlen($prefix); if (strncmp($prefix, $class, $len) !== 0) &#123; return; &#125; $relativeClass = substr($class,$len); $file = $baseDir . str_replace('\\','/',$relativeClass) . '.php'; if (file_exists($file)) &#123; require $file; &#125;&#125;);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP常用知识点]]></title>
    <url>%2F2019%2F07%2F01%2FHTTP%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[##三次握手HTTP是基于TCP协议基础上的，TCP是传输层，HTTP是应用层TCP在连接时有三次握手第一次握手，首先客户端向服务器端发出一次请求，发送一个随机码第二次握手，服务器接受到随机码收，将随机码+1返回，并返回确认信息(ACK=1)和自己的随机码第三次握手，客户端接收到确认信息，并验证随机码，再次向服务器发送确认信息(ACK=1)，当服务器接收到确认信息后，TCP完成建立连接。 ##四次挥手第一次挥手，客户端想服务器端发出请求，信息FIN=1，表示要断开连接第二次挥手，服务器端接受到请求进入CLOSE-WAIT(关闭等待状态)，此时客户端已经没有数据要发送了，但是服务器若要发送数据，客户端依然能接受。第三次挥手，服务器数据发送完毕，就向客户端发送连接释放报文，此时服务器进入最后确认状态，等待客户端的确认第四次挥手，客户端接收到服务器的连接释放报文后，发送ACK=1确认信息，此时客户端进入TIME-WAIT状态，经过2*MSL（最长报文寿命）的时间后，客户端断开连接 ##状态码 ###2XX 成功状态码，请求正常处理完毕 200 OK，表示从客户端发来的请求在服务器端正常处理了 204 No Content，该状态码代表服务器接受的请求已经处理成功，但在返回的相应报文中，不含实体的主题部分，另外也不允许返回任何实体的主体，比如当浏览器发出请求处理后，返回204状态码，那么浏览器显示的页面不会发生更新。 206 Partial Contetn，该状态码表示客户端进行了范围请求，而服务器成功的执行了这部分的GET请求。相应报文中包含由Contetn-Range指定范围的实体内容###3XX 重定向状态码，需要进行附加操作完成请求 301 Moved Permanently 永久重定向，该状态码表示请求的资源已分配了新的URL，以后应使用资源现在指向的URL。 302 Found 临时重定向，该状态码表示请求的资源已分配了新的URL，希望本次使用新的URL。 303 See Other 该状态码用于请求对应的资源存在另一个URL，应使用GET方法定向获取请求的资源。 304 Not Modified 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但为满足条件的情况。在客户端向服务端发送http请求时，若返回状态码为304 Not Modified 则表明此次请求为条件请求。在请求头中有两个请求参数：If-Modified-Since 和 If-None-Match。当客户端缓存了目标资源但不确定该缓存资源是否是最新版本的时候, 就会发送一个条件请求。在进行条件请求时,客户端会提供给服务器一个If-Modified-Since请求头,其值为服务器上次返回响应头中Last-Modified值,还会提供一个If-None-Match请求头,值为服务器上次返回的ETag响应头的值。服务器会读取到这两个请求头中的值,判断出客户端缓存的资源是否是最新的,如果是的话,服务器就会返回HTTP/304 Not Modified响应头, 但没有响应体.客户端收到304响应后,就会从本地缓存中读取对应的资源。 所以：当访问资源出现304访问的情况下其实就是先在本地缓存了访问的资源。###4XX 客户端错误状态码，服务器无法处理请求 400 Bad Request 该状态码表示请求报文中存在语法错误，当错误发生时，需修改请求的内容后再次发送请求。 401 Unauthorized 该状态码表示发送的请求需要通过HTTP认证的认证信息 403 Forbidden 该状态码表示对请求的资源的访问被服务器拒绝了，服务器端没必要给出拒绝的详细理由，但是如果想做说明的话，可以在实体的主体部分对原因进行描述。 404 Not Found 该状态码表明服务器上无法找到请求的资源。###5XX 服务器错误状态码，服务器请求处理出错 500 Internal Server Error 该状态码表明服务器端在执行请求的时候发生了错误，也有可能是web应用存在的bug或临时故障。 503 Service Unavailable 该状态表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求##通信数据转发程序###代理 代理是一种具有转发功能的应用程序，扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器的响应并转发给客户端。代理服务器的基本行为就是接收客户端发来的请求并转发给其他服务器，代理不改变请求的URL，会直接发送给前方持有资源的目标服务器。持有资源的目标服务器接收到请求后返回的相应经过代理服务器后传回给客户端。在HTTP通信的过程中，可级联多台代理服务器，请求和相应的转发会经过数台类似锁链一样的连接起来的代理服务器。转发时需要附加Via首部字段表标出经过的主机信息。###网关 网关是转发其他服务器通信数据的服务器，接收从客户端发来的请求时，它就像自己拥有资源的服务器一样对请求进行处理。有时客户端可能都不会察觉，自己通信的目标是一个网关。利用网关可以由HTTP请求转换为其他协议通信利用网关可以提高通信的安全性， 因为可以在客户端与网关之间的通信线路上加密以确保连接的安全，比如网关可以连接数据库，另外在WEB购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。###隧道 隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。隧道可以按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信，隧道的目的是确保客户端能与服务器进行安全的通信。##通用首部字段###Cache-Control 操作缓存的工作机制public：明确表示其他用户也可以使用该缓存private：响应只以特定用户作为对象no-cache：no-cache不代表客户端不进行缓存，客户端依旧进行缓存，只是在每次使用资源的时候需要向服务器确认下资源可用否，可用的话服务器将不再返回新的资源，客户端使用缓存no-store：告诉客户端不要进行缓存max-age：设置缓存的最长时间s-max-age：和max-age指令相同，但是用于代理服务器（CDN），s-max-age的优先级高于max-age，如果存在s-max-age，则会覆盖掉max-age和Expires header。min-fresh：要求缓存服务器返回至少还未过指定时间的缓存资源，比如指定了min-fresh为60秒后，过了60秒的资源都无法返回了。max-stale：使用max-stale，可指示缓存资源，即使过期但是只要不超过max-stale的值，依旧返回给客户端only-if-cached：仅在缓存服务器本地缓存目标资源的情况下才会要求返回，若发生请求缓存服务器的本地缓存无响应，则返回状态码504must-revalidate：会向服务器再次验证即将返回的响应缓存目前是否依然有效，若无法连通服务器再次获取有效资源的话，缓存必须给客户度一条504状态码。使用了must-revalidate会忽略max-staleproxy-revalidate：要求所有缓存服务器在接收到客户端带有该指令的请求返回响应前，必须再次校验缓存的有效性no-transform：Content-Encoding, Content-Range, Content-Type等HTTP头不能由代理修改###connection 控制不再转发给代理的首部字段 管理持久连接###Upgrade用于检测HTTP协议及其他协议是否可以使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议，使用时connection需要指定为upgrade###Transfer-Encoding规定了传输报文主体时采用的编码方式。HTTP/1.1的传输编码方式仅对分块传输数据有效###Via使用首部字段Via是为了追踪客户端和服务器之间的请求和相应报文的传输路径。报文经过代理或网关时，会先在首部Via中附加该服务器的信息，然后再进行转发，首部Via不仅可以用于追踪报文的转发，还可以避免请求回环的发生。##请求首部字段 请求首部字段是从客户端发送请求报文中所使用的字段，用于补充请求的附加信息，客户端信息，对响应内容相关的优先级内容Accept Accept首部字段可以通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级text/html,text/plain,text/cssapplication/xhtml+xml,application/xmlimage/jpeg,image/png,image/gif###Accept-Charset Accept-Charset首部字段可以用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。Accept-Charset:iso-8859-5,unicode-1-1;q=0.8(q用来表示优先级)###Accpet-Encoding Accept-Charset首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序，可以一次性指定多个内容编码。 gzip compress deflate identity###Accept-Language Accept-Language首部字段用来告知服务器用户代理能够处理的自然语言集，以及自然语言集的相对优先级，可以一次指定多个自然语言集。Accept-Language:zh-cn;q=0.7,en-us,en;q=0.3###Authorization Authorization首部字段是用来告诉服务器，用户代理的认证信息###From 用来告知服务器使用用户代理的用户的电子邮件地址。From:xxx@qq.com###Host 首部字段Host告诉服务器，请求的资源所处的互联网主机名和端口号。 Host首部字段在HTTP/1.1范围内是唯一一个必须包含在请求内的首部字段 首部字段Host和以单台服务器分配多个域名的虚拟主机工作机制有很密切的关系，这是HOST必须存在的意义###If-Match（与If-None-Match相反） 服务器会对比If-Match和ETag的值，仅当两个值一致时，才会执行请求，反之，则返回412Precodition Failed的响应。还可以使用*指定If-Match的值，针对这种情况，服务器会忽略ETag的值，只要资源存在就请求处理。###If-Modified-Since(与If-Unmodified-Since相反) 如果在指定的时间之后，资源发生了更新，服务器会接受请求否则不会。 可以通过Last-Modified来确定资源的更新日期###Max-Forwards 可以指定最多转发次数###Range 告知服务器资源的指定范围，可以只获取部分资源Range:bytes=5001-10000###Referer 告知服务器请求的原始资源uriReferer:http://www.baidu.com###User-Agent 用于传达浏览器种类###Cookie 首部字段Cookie，会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie，接收到多个Cookie时，同样可以以多个Cookie形式发送。##响应首部字段###Accept-Ranges 用来告知客户端服务器是否能处理范围请求，可指定的字段值有两种，可处理范围请求时指定其为bytes，反之指定为none###Age 用来告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。###ETag 用来告知客户端实体标识，是一种可将资源以字符串形式作唯一标识的方式，服务器会为每份资源配置对应的ETag，资源更新时也需要更新ETag###Location 可以将响应接收方引导至某个与请求URI位置不同的资源。 基本上该字段都会配合3xx：Redirection的相应提供重定向的URI###Server 告知客户端当前服务器上安装的HTTP服务器应用程序的信息。###Set-Cookie 当服务器准备开始管理客户端的状态时，会事先告知各种信息。字段属性值 NAME=VALUE 赋予Cookie的名称和其值（必需项） expires=Date Cookie的有效期（若不明确指定则默认为浏览器关闭前） path=PATH将服务器上的文件目录作为Cookie的适用对象 domain=域名 作为Cookie适用对象的域名 Secure 仅在HTTPS安全通信时才会发送Cookie HttpOnly 加以限制，使Cookie不能被Javascript脚本访问 Set-Cookie:name=value;HttpOnly##实体首部字段 实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间与实体相关的信息，在请求和响应两方的HTTP报文中都含有与实体相关的首部字段###Allow 用于通知客户端能够支持的Request-URI指定资源的所有HTTP方法，当状态码接收到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回。###Content-Language 首部字段Content-Language会告知客户端，实体主体使用的自然语言###Content-Range 针对范围请求，返回响应时使用的首部字段Contetn-Range,能告知客户端作为响应返回的实体的哪个部分符合范围请求。Content-Range:bytes 5001-10000/10000###Content-Type 说明了实体主体内对象的媒体类型。###Expires 首部字段Expires会将资源失效的日期告知客户端，缓存服务器在接收到含有首部字段Expires的响应后，会以缓存来应答请求，在Expires字段值指定的时间前，响应的副本会一直被保存，当超过指定时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。 源服务器不希望缓存服务器对资源缓存时，最好在Expires字段内写入首部字段Date相同的时间值。 但是，当首部字段Cache-Control有指令max-age指令时，比起首部字段expires，会优先处理max-age指令。###Last-Modified 首部字段Last-Modified指明资源最终修改的时间，一般来说这个值就是Request-URI指定资源被修改的时间。但类似使用CGI脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发中的常见问题【陆续整理】]]></title>
    <url>%2F2019%2F06%2F05%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E3%80%90%E9%99%86%E7%BB%AD%E6%95%B4%E7%90%86%E3%80%91%2F</url>
    <content type="text"><![CDATA[开发中的常见问题【陆续整理】##204问题 项目都是前后端分离的，上线几个月以来，发现一个很奇怪的问题，每次前端发起请求，通过浏览器的开发者工具都能看到在Network下同一个url有两条请求，第一条请求的Method为OPTIONS，第二条请求的Method才是真正的GET或者POST，并且，第一条请求无数据返回，第二条请求才会返回正常的数据。发现这个问题之后，立即组织搜索问题产生的原因以及解决方案。在网上搜索了大量资料，得到的一个结论是：第一个OPTIONS的请求是由Web服务器处理跨域访问引发的。网上资料显示，OPTIONS是一种“预检请求”，浏览器在处理跨域访问的请求时如果判断请求为复杂请求，则会先向服务器发送一条预检请求，根据服务器返回的内容浏览器判断服务器是否允许该请求访问。如果web服务器采用cors的方式支持跨域访问，在处理复杂请求时这个预检请求是不可避免的。 查询代码发现，我们的web服务器确实采用的是cors来解决跨域访问的问题，并且我们在header中添加了自定义参数，导致我们的每次请求都为复杂请求，从而产生了每次请求都会发送两条请求的现象。 问题的原因找到了，就要想办法解决这个问题。既然浏览器在处理复杂请求时，不可避免的要发送预检请求，那么能否减少预检请求的次数呢？比如，预检一次设置一个有效期，在有效期内不再重复预检。顺着这个思路，继续搜索相关资料，最终发现设置Access-Control-Max-Age这个参数即可达到预期目标。该参数用来指定本次预检请求的有效期，单位为秒。在服务器上设置该参数之后，问题解决了，大快人心！！！参考资料：https://blog.csdn.net/charleslei/article/details/51906635]]></content>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次被老婆XX的经历]]></title>
    <url>%2F2019%2F06%2F03%2F%E4%B8%80%E6%AC%A1%E8%A2%AB%E8%80%81%E5%A9%86XX%E7%9A%84%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[最美的不在窗外而在眼前 第三次来到这座城市第一次的兴奋第二次的迷茫这一次的自由自由是因为有我最爱的你陪伴自由是因为清晰了未来想要的生活 没有去太多的地方，超过了50%的时间就在酒店里没有吃太多的美食，甚至几餐都吃的外卖但是感受了几天和你朝夕相伴的时光，于我而言，这样的旅行是接近完美的，只因为有你的陪伴，唯一不足的是安排好行程，你应该多少有点失望吧，还是想写下没有去做的原因，毕竟这座城市是你和别人先来的，我不知道你们去过哪些地方，我害怕同样的地点会勾起你的回忆 好在未来还很长，这世界上还有太多的地方等着我们去开发，因为有你所以自由，因为有你未来可期]]></content>
      <tags>
        <tag>爱情</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我们的故事]]></title>
    <url>%2F2019%2F05%2F21%2F%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[我们的故事 今天是2019.05.21 特别的日子，此文用于记录我们之间的点滴 2019.05.21今天在地铁上，快到世纪城了，我故意把你抱紧，希望你不要去寻找，希望你不要推开我，但能感觉到你还是有去寻找，但是我没办法告诉你，因为我害怕这一切都只是我自己太敏感的幻想。你说我生气了，并没有，我只是不清楚你心中的想法。陪你洗了头，回家的路上，你问，以后我们能养得起我们的娃么？我说要看怎么养了，我也没养过。放心吧，我一定会200%的努力工作，养你，养娃。半年快乐~ 2019.06.03今天开始强行逼自己加班学习，虽然很想立马去见你，拥抱你，但是比起短暂的现在，我希望能给你美好的未来。多希望睡前有你，醒来你还在的日子早点到来。刚吃了饭，再坚持一个半小时就能见到你了，加油鸭！见了你，虽然表面波澜不惊，但是内心早已汹涌澎湃了，哈哈哈哈哈哈，开心回家跑了步，再学习一会儿就睡觉啦，醒来又可以见到你了，明天给你做南瓜粥鸭 2019.06.05快下班了，你发消息问我晚上吃什么，本来想说我已经吃过了，但是又想和你一起吃个晚饭，所以告诉你我想吃凉面，嘻嘻嘻，其实我已经吃过凉面啦我自己吃的凉面 我们一起吃的冷沾沾 我们一共吃了27个冷沾沾，你问我吃饱没，其实我已经撑啦，幸福就是能和你一起吃早餐和晚餐!]]></content>
      <tags>
        <tag>爱情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之——观察者模式]]></title>
    <url>%2F2019%2F05%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[顾名思义，观察者模式可以用于监控一个程序的变动，从而做出对应的逻辑。 需求：登录是绝大数产品中拥有的功能，也是很重要的功能，当前我们已经实现了一个登录的方法可以完成登录的基本功能，见如下代码12345678910&lt;?phpclass Login&#123; public function doLogin() &#123; if(rand(1,2)==1) &#123; echo '假装登录成功'; &#125; &#125;&#125; 好了，当前我们已经拥有了登录的方法了，这个时候产品经理又提出在登录成功后我们需要记录下用户的ip，那么程序员小哥哥们又是一波操作，把代码改成了下面这样。 12345678910111213141516&lt;?phpclass Login&#123; public function doLogin() &#123; if(rand(1,2)==1) &#123; echo '假装登录成功'; $this-&gt;doLog(); &#125; &#125; public function doLog() &#123; echo '记录ip'; &#125;&#125; 这个时候我们有了记录ip的方法，产品经理又提出，我们要在失败的时候记录下用户登录失败的原因，fine… 996走一波1234567891011121314151617181920212223&lt;?phpclass Login&#123; public function doLogin() &#123; if(rand(1,2)==1) &#123; echo '假装登录成功'; $this-&gt;doLog(); &#125;else &#123; $this-&gt;doError(); &#125; &#125; public function doLog() &#123; echo '记录ip'; &#125; public function doError() &#123; echo 'why？？？'; &#125;&#125; 通过两次的迭代，小哥哥为我们的登录模块添加上了记录ip和记录错误的功能，我们可以发现这种迭代的方法完全违背了代码的开闭原则，我们每次的功能调整都会影响到原有的login方法，所以在这种情况下，我们的观察者模式就登上了舞台。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?phpnamespace Observer;interface Observerable&#123; public function attach(Observer $observer); public function detach(Observer $observer); public function notify();&#125;interface Observer&#123; public function update(Observerable $observerable);&#125;class Login implements Observerable&#123; private $observers; private $status; public function __construct() &#123; $this-&gt;status = rand(1,2); &#125; public function getStatus() &#123; return $this-&gt;status; &#125; public function attach(Observer $observer) &#123; $this-&gt;observers[] = $observer; &#125; public function detach(Observer $observer) &#123; $newObservers = []; foreach($this-&gt;observers as $o) &#123; if($o !== $observer) &#123; $newObservers[] = $o; &#125; &#125; $this-&gt;observers = $newObservers; &#125; public function notify() &#123; foreach($this-&gt;observers as $o) &#123; $o-&gt;update($this); &#125; &#125;&#125;class LoginLogObserver implements Observer&#123; public function update(Observerable $observerable) &#123; if($observerable-&gt;getStatus()==1) &#123; echo '记录ip更灵活'; &#125; &#125;&#125;class LoginErrObserver implements Observer&#123; public function update(Observerable $observerable) &#123; if($observerable-&gt;getStatus()==2) &#123; echo 'NO WHY'; &#125; &#125;&#125;$login = new Login();$login-&gt;attach(new LoginLogObserver());$login-&gt;attach(new LoginErrObserver());$login-&gt;notify(); 在最新版本的代码中，我们重构了代码，按照观察者模式说先我们定义了一个可被观察的接口，要求实现该接口的类必须包含添加观察者，移除观察者，观察者执行的三个方法。同时我们定义了一个观察者的接口，要求实现该接口的类必须包含更新方法用于同步被观察者的操作。定义好接口后，我们定义了实现类，登录类实现被观察者接口，日志记录类，错误记录类实现了观察者接口。此时我们的代码比之前灵活了很多，通过组合的方式，我们可以很灵活的添加和删除对登录方法的监控，并且完全不会影响到登录的逻辑，满足了开闭原则。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心静如水]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%BF%83%E9%9D%99%E5%A6%82%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[夏日的标配大概就是西瓜🍉配音乐🎵吧 结束了一天的工作，冲洗掉了一身的汗渍，坐在离小胡最近的位置，听歌，看书，吃水果。很久没有一个人这么安静的坐着干自己的事情了，这里的安静指心中的安静，至于为什么能够安静大概是因为我知道小胡已经入睡了，因此我不用操心她熬夜伤身的问题了，今天的工作完成了，因此我不用担心还有没改完的bug的问题了，今天的训练完成了，因此我不用担心这个点吃西瓜会长胖的问题了(虽然确实可能会长胖)，总结一下大概是因为在这一刻几乎没有了任何的欲望吧。如果人能控制自己的欲望，是不是就能一直保持这样的状态了呢？那无欲无求的人是不上进的咸鱼还是看透一切的大师呢？]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之——外观模式]]></title>
    <url>%2F2019%2F05%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[外观模式（Facade）,他隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。这种类型的设计模式属于结构性模式。为子系统中的一组接口提供了一个统一的访问接口，这个接口使得子系统更容易被访问或者使用。 我们当前有一个需求是完成用户的购票功能，逻辑是用户需要先登录，然后选票，然后进行验证码校验，最后完成支付 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass User&#123; public function doLogin() &#123; echo '先登录'; &#125;&#125;class Ticket&#123; public function getTicket() &#123; echo '选票'; &#125;&#125;class Verify&#123; public function doVerify() &#123; echo '验证码'; &#125;&#125;class Pay&#123; public function doPay() &#123; echo '支付'; &#125;&#125;$user = new User();$user-&gt;doLogin();$ticket = new Ticket();$ticket-&gt;getTicket();$verify = new Verify();$verify-&gt;doVerify();$pay = new Pay();$pay-&gt;doPay(); 在当前版本中，我们分别定义了四个类，每个类负责各自的功能，当客户端需要实现业务逻辑的时候显得比较麻烦，特别是当有多处地方进行该业务操作的时候，如果业务逻辑发生了变动，所有地方都需要进行修改，因此我们对代码进行了修改。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpclass User&#123; public function doLogin() &#123; echo '先登录'; &#125;&#125;class Ticket&#123; public function getTicket() &#123; echo '选票'; &#125;&#125;class Verify&#123; public function doVerify() &#123; echo '验证码'; &#125;&#125;class Pay&#123; public function doPay() &#123; echo '支付'; &#125;&#125;class HN&#123; public function buyTicket() &#123; $user = new User(); $user-&gt;doLogin(); $ticket = new Ticket(); $ticket-&gt;getTicket(); $verify = new Verify(); $verify-&gt;doVerify(); $pay = new Pay(); $pay-&gt;doPay(); &#125;&#125;$hn = new HN();$hn-&gt;buyTicket(); 在新的版本中，我们创建了一个黄牛类来帮助我们买票，黄牛的buyTicket方法完成了所有的业务逻辑，因此客户端在任何地方只需要委托黄牛来帮助完成购票的功能即可。 这种方式既外观模式，通过封装交互，简化调用]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之——装饰器模式]]></title>
    <url>%2F2019%2F05%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。&lt; !–more–&gt; 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpabstract class Car&#123; public abstract function run();&#125;abstract class DerectoreBase extends Car&#123; protected $car; public function __construct(Car $car) &#123; $this-&gt;car = $car; &#125;&#125;class ColorDerector extends DerectoreBase&#123; public function run() &#123; echo "颜色\n"; $this-&gt;car-&gt;run(); &#125;&#125;class SpeedDerector extends DerectoreBase&#123; public function run() &#123; echo "速度\n"; $this-&gt;car-&gt;run(); &#125;&#125;class Benz extends Car&#123; public function run() &#123; echo "This is Benz"; &#125;&#125;$tmp = new ColorDerector(new SpeedDerector(new Benz()));$tmp-&gt;run(); 在上面的代码中，我们首先定义了一个基类，并且有一个run的抽象方法，其他类都继承于该类。然后创建了一个装饰器的基类，该类中有一个car的属性，用于保存被修饰的对象。接着我们创建了两个具体的装饰类用于实现具体的装饰功能然后我们创建了一个奔驰类继承了汽车基类此时我们通过实例化装饰类并且把奔驰类作为参数传入就可以实现装饰功能，以及多级装饰功能。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之——组合模式]]></title>
    <url>%2F2019%2F05%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之——工厂模式]]></title>
    <url>%2F2019%2F04%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书计划]]></title>
    <url>%2F2019%2F01%2F01%2F%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[专业 程序员的自我修养 【需反复阅读】 深入PHP面向对象、模式与实践(第2版) 【无需再次阅读】 GO语言编程 【部分章节可再次阅读】 图解HTTP 深入理解RPC：自建分布式高并发RPC服务 Docker——容器与容器云 Modern PHP 【进行中】 Kafka权威指南 Redis设计与实现 大型网站技术架构 高性能MySQL 数据结构与算法分析 操作系统 其他 我们仨 【可再次阅读】 挪威的森林 活着 数学之美【进行中】 围城 【进行中】 代码整洁之道 禅者的初心 软技能 : 代码之外的生存指南 心流 程序员的职业素养 终身成长 重构 : 改善既有代码的设计 生命3.0 程序员的思维修炼 : 开发认知潜能的九堂课]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
