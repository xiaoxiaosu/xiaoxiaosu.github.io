<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Author Name,name@example.com"><title>Go语言核心编程读书笔记 · 爱吃兔子的小萝卜</title><meta name="description" content="数组，字符串，切片数组数组是值类型，虽然数组元素的值可以被修改，但是数组本身的赋值和函数传参，都是以整体复制的方式处理的。
数组是一个由固定长度的特定类型的元素组成的序列，一个数组可以由零个或者多个元素组成。
数组的长度是数组类型的组成部分，因为数组的长度是数组类型的一个部分，不同长度的或者不同类型"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/favicon.png" style="width:127px;border-radius: 300px;"><h3 title><a href="/">爱吃兔子的小萝卜</a></h3><div class="description"><p>爱老婆，爱健身，爱工作</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/3888494791/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/xiaoxiaosu"><i class="fa fa-github"></i></a></li></ul><div class="footer"><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Go语言核心编程读书笔记</a></h3></div><div class="post-content"><h2 id="数组，字符串，切片"><a href="#数组，字符串，切片" class="headerlink" title="数组，字符串，切片"></a>数组，字符串，切片</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是值类型，虽然数组元素的值可以被修改，但是数组本身的赋值和函数传参，都是以整体复制的方式处理的。</p>
<p>数组是一个由固定长度的特定类型的元素组成的序列，一个数组可以由零个或者多个元素组成。</p>
<p>数组的长度是数组类型的组成部分，因为数组的长度是数组类型的一个部分，不同长度的或者不同类型的数据组成的数组都是不同类型的数组，无法直接赋值。</p>
<h4 id="数组的定义方式"><a href="#数组的定义方式" class="headerlink" title="数组的定义方式"></a>数组的定义方式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组内存结构"><a href="#数组内存结构" class="headerlink" title="数组内存结构"></a>数组内存结构</h4><p>Go语言中的数组是值语义，一个数组变量既表示整个数组，并不是隐式的指向第一个元素的指针。</p>
<p>当一个数组变量被赋值或者传递时，实际上会复制整个数组。</p>
<h4 id="空数组"><a href="#空数组" class="headerlink" title="空数组"></a>空数组</h4><p>长度为0的数组在内存中不占用空间，空数组可以用于强调某种特有类型的操作时避免分配额外的内存</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> [<span class="number">0</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c1 &lt;- [<span class="number">0</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>() <span class="comment">//计算数组的长度</span></span><br><span class="line"><span class="built_in">cap</span>() <span class="comment">//计算数组的容量</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>GO语言字符串的底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素进行修改。</p>
<p>字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制</p>
<h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data <span class="keyword">uintptr</span> <span class="comment">//指向底层的字节数组</span></span><br><span class="line">  Len <span class="keyword">int</span> <span class="comment">//字符串的字节长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片的底层数据也是数组，但是每个切片还有独立的长度和容量信息，切片赋值和函数传参时也是将切片头信息部分按传值方式处理。因为切片头含有底层数组的指针，所以它的赋值也不会导致底层数组的复制</p>
<h4 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data <span class="keyword">uintptr</span></span><br><span class="line">  Len <span class="keyword">int</span></span><br><span class="line">  Cap <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	a []<span class="keyword">int</span> <span class="comment">//nil切片，和nil相等，一般用来表示一个不存在的切片</span></span><br><span class="line">  b = []<span class="keyword">int</span>&#123;&#125; <span class="comment">//空切片，和nil不相等，一般用来表示一个空的集合</span></span><br><span class="line">  c = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">//有三个元素的切片，len和cap都为3</span></span><br><span class="line">  d = c[:<span class="number">2</span>] <span class="comment">//有两个元素的切片 len=2 cap=3</span></span><br><span class="line">  e = c[:<span class="number">0</span>] <span class="comment">//0个元素的切片 len=0 cap=3</span></span><br><span class="line">  f = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>) <span class="comment">//有三个元素的切片 len=3 cap=3</span></span><br><span class="line">  g = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>,<span class="number">6</span>) <span class="comment">//有三个元素的切片 len=3 cap=6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><p>切片可以和nil进行比较，只有当切片底层数据指针为空时，切片本身为nil，这时候切片的长度和容量信息将是无效的</p>
<p>在对切片本身赋值或参数传递时，和数组指针的操作类似，只是复制切片头信息，并不会复制底层的数据</p>
<h4 id="内置函数-1"><a href="#内置函数-1" class="headerlink" title="内置函数"></a>内置函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">append</span>() <span class="comment">// 增加切片元素，在容量不足的情况下，append操作会导致重新分配内存，可能导致巨大的内存分配和复制数据代价</span></span><br></pre></td></tr></table></figure>
<h4 id="切片内存技巧"><a href="#切片内存技巧" class="headerlink" title="切片内存技巧"></a>切片内存技巧</h4><blockquote>
<p>切片高效操作的要点是降低内存分配的次数，尽量保证append操作不会超出cap的容量，降低触发内存分配的次数和每次分配内存的大小</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容切片</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">0</span>) <span class="comment">//切片扩展一个空间</span></span><br><span class="line"><span class="built_in">copy</span>(a[i+<span class="number">1</span>:], a[i:]) <span class="comment">//a[i:] 向后移一位</span></span><br><span class="line">a[i] = x <span class="comment">//设置新添加的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除切片元素</span></span><br><span class="line">a = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">a = a[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用空切片的特性删除切片元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">  b := [s:<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> _,x := <span class="keyword">range</span> s &#123;</span><br><span class="line">    <span class="keyword">if</span> x != <span class="string">' '</span> &#123;</span><br><span class="line">      b = <span class="built_in">append</span>(b, x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提高GC效率</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindPhoneNum</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">  b, _ := ioutil.ReadFile(filename)</span><br><span class="line">  <span class="keyword">return</span> regexp.MustCompile(<span class="string">"[0-9]+"</span>).Find(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这段代码返回的[]byte指向保存整个文件的数组，因为切片引用了整个原始数组，导致自动垃圾回收器不能及时释放底层数组的空间，一个小的需求可能导致需要长时间保存整个文件数据。通过下面的方式进行优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindPhoneNum</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">  b, _ := ioutil.ReadFile(filename)</span><br><span class="line">  regexp.MustCompile(<span class="string">"[0-9]+"</span>).Find(b)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;&#125;, b...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数，方法与接口"><a href="#函数，方法与接口" class="headerlink" title="函数，方法与接口"></a>函数，方法与接口</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在GO语言中，函数是第一类对象，我们可以将函数保存到变量中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数</span></span><br><span class="line"><span class="keyword">var</span> Add = <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><blockquote>
<p>一般我们把匿名函数捕获了外部函数的局部变量的函数称为匿名函数</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;<span class="built_in">println</span>(i)&#125;()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//因为闭包，每个defer语句延迟执行的函数引用的都是同一个i迭代变量，在循环结束后，i都为3，可以通过以下方法解决该问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;<span class="built_in">println</span>(i)&#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="切片作为入参"><a href="#切片作为入参" class="headerlink" title="切片作为入参"></a>切片作为入参</h4><p>GO语言中，如果以切片作为参数调用函数时，有时候会给人一种参数采用了引用方式传递的假象：因为在被调用函数内部可以修改传入的切片元素。其实，任何可以通过函数参数修改调用参数的情形，都是因为函数参数中显示或者隐式的传入了指针参数。</p>
<p>因为切片中的底层数组部分是通过隐式指针传递（指针本身依然是传值的，但是指针指向的却是同一份数据）,所以被调用函数是可以通过指针修改调用参数切片中的数据。除了数据之外，切片结构还包含了切片长度和切片容量的信息，这两个信息也是传值的，如果被调用函数中修改了Len或Cap信息的话，就无法反映到调用参数的切片中，这时候我们一般会通过返回修改后的切片来更新之前的切片，这也是为什么内置的append必须要返回一个切片的原因</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twice</span><span class="params">(x []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> x &#123;</span><br><span class="line">  	x[i] *= <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IntSliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data []<span class="keyword">int</span></span><br><span class="line">  Len	<span class="keyword">int</span></span><br><span class="line">  Cap <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twice</span><span class="params">(x IntSliceHeader)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; x.Len; i++ &#123;</span><br><span class="line">    x.Data[i] *= <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>GO语言函数的递归调用深度逻辑上没有限制，函数调用的栈是不会出现溢出错误的，因为GO语言运行时会根据需要动态的调整函数栈的大小。每个goroutine刚启动时只会分配很小的栈，根据需要动态调整栈的大小。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>GO语言中方法是关联到类型的，这样可以在编译阶段完成方法的静态绑定。</p>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123;X, Y <span class="keyword">float64</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColorPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">  Point</span><br><span class="line">  Color color.RGBA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><pre><code>&gt; Go的接口类型是对其他类型行为的抽象和概括，Go语言的接口类型独特之处在于它是满足隐式实现的鸭子类型
</code></pre><p>这种设计可以让你创建一个新的接口类型满足已经存在的的具体类型却不用去破坏这些类型原有的定义，当我们使用的类型来自于不受我们控制的包时，这种设计尤其灵活有用。</p>
<p>接口在Go语言中无处不在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//用于输出的接口</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">io</span>.<span class="title">Writer</span> <span class="title">interface</span></span> &#123;</span><br><span class="line">  Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>,err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置的错误接口</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的代码我们可以通过定制自己的输出对象，将每个字符转为大写字符后输出</span></span><br><span class="line"><span class="keyword">type</span> UpperWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">  io.Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *UpperWriter)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.Writer.Write(bytes.ToUpper(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Fprintln(&amp;UpperWriter&#123;os.Stdoout&#125;, <span class="string">"hello, world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言中，对于基础类型（非接口类型）不支持隐式转换，我们无法将一个int类型的值直接赋给int64类型的变量，也无法将int类型的值赋值给底层是int类型的新定义命名类型的变量。</p>
<h4 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">func</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">xxx</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">  animal <span class="comment">//加入了接口，但是没有实现具体的方法，实现了虚拟继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Goroutine和系统线程"><a href="#Goroutine和系统线程" class="headerlink" title="Goroutine和系统线程"></a>Goroutine和系统线程</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>每个系统级的线程都会有一个固定大小的栈（默认2MB），这个栈主要用来保存函数调用时的参数和局部变量。</p>
<p>固定了栈的大小导致了两个问题，一个是对于只需要很小的栈空间的线程，是一种浪费，另一个是对于少数需要巨大栈空间的线程存在栈溢出的风险。Goroutine解决了这个问题。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>一个Goroutine会以一个很小的的栈启动（可能是2kb或4kb），当遇到深度递归导致当前栈空间不足时，Goroutine会根据需要动态的伸缩栈的大小，因为启动的代价很小，所以我们可以轻易的启动成千上万个Goroutine。</p>
<p>Go的运行时还包含了自己的调度器，这个调度器使用了一些技术手段，可以在n个操作系统上多工调度m个Goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的Goroutine。</p>
<p>Goroutine采用半抢占式的协作调度，只有在当前Goroutine发生阻塞时才会调度；同时发生在用户态，调度器会根据具体函数只保存必要的寄存器，切换的大家要比系统级线程低的多</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作是指并发编程中，最小且不可并行化的操作。</p>
<p>如果多个并发体对同一个共享资源进行的操作是原子的话，那么同一时刻最多只能有一个并发体对该资源进行操作。</p>
<p>一般情况下原子的操作都是通过互斥来保证的，如下代码</p>
<h4 id="互斥锁实现原子操作"><a href="#互斥锁实现原子操作" class="headerlink" title="互斥锁实现原子操作"></a>互斥锁实现原子操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">struct</span>&#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++ &#123;</span><br><span class="line">		total.Lock()</span><br><span class="line">		total.value += <span class="number">1</span></span><br><span class="line">		total.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(&amp;wg)</span><br><span class="line">	<span class="keyword">go</span> worker(&amp;wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Println(total.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用golang中自带的atomic"><a href="#使用golang中自带的atomic" class="headerlink" title="使用golang中自带的atomic"></a>使用golang中自带的atomic</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++ &#123;</span><br><span class="line">		total = atomic.AddUint64(&amp;total, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(wg)</span><br><span class="line">	<span class="keyword">go</span> worker(wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Println(total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="利用atomic和互斥锁实现单例模式"><a href="#利用atomic和互斥锁实现单例模式" class="headerlink" title="利用atomic和互斥锁实现单例模式"></a>利用atomic和互斥锁实现单例模式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	instance *singleton</span><br><span class="line">	initialized <span class="keyword">uint32</span></span><br><span class="line">	mu sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Instance</span><span class="params">()</span> *<span class="title">singleton</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;initialized) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> instance</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;initialized, <span class="number">1</span>)</span><br><span class="line">		instance = &amp;singleton&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="利用golang内置库Once实现单例模式"><a href="#利用golang内置库Once实现单例模式" class="headerlink" title="利用golang内置库Once实现单例模式"></a>利用golang内置库Once实现单例模式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	instance *singleton</span><br><span class="line">  once sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Instance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">  Once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    instance = &amp;singleton</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h2><blockquote>
<p>并发不是并行，并发更多关注的是程序设计层面，并发的程序完全可以顺序执行，只有在真正的多核cpu上才可能真正的同时运行</p>
</blockquote>
<h3 id="不要通过共享内存来通信，而用通信来共享内存"><a href="#不要通过共享内存来通信，而用通信来共享内存" class="headerlink" title="不要通过共享内存来通信，而用通信来共享内存"></a>不要通过共享内存来通信，而用通信来共享内存</h3><p>在并发编程中，对共享资源的正确访问需要精确的控制，在目前绝大多数语言中，都是通过加锁等线程同步方案来解决这一问题，在go语言中将共享的值通过channel传递，在任意给定时刻，最好只有一个goroutine能够拥有该资源，数据竞争从设计层面就被杜绝了。</p>
<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer</span><span class="params">(basic <span class="keyword">int</span>,c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	res := basic*<span class="number">2</span></span><br><span class="line">	c &lt;- res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> Producer(<span class="number">2</span>, c)</span><br><span class="line">	<span class="keyword">go</span> Producer(<span class="number">3</span>,c)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> Consumer(c)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发布订阅模型"><a href="#发布订阅模型" class="headerlink" title="发布订阅模型"></a>发布订阅模型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	subscriber <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	topicFunc <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">Publisher</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">	m sync.Mutex <span class="comment">//读写锁</span></span><br><span class="line">	buffer <span class="keyword">int</span> <span class="comment">//订阅队列的缓存大小</span></span><br><span class="line">	timeout time.Duration <span class="comment">//发布超时时间</span></span><br><span class="line">	subscribers <span class="keyword">map</span>[subscriber] topicFunc <span class="comment">//订阅者信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建一个发布者对象，可以设置发布超时时间和缓存队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPublisher</span><span class="params">(publishTimeout time.Duration, buffer <span class="keyword">int</span>)</span> *<span class="title">Publisher</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Publisher&#123;</span><br><span class="line">		buffer: buffer,</span><br><span class="line">		timeout: publishTimeout,</span><br><span class="line">		subscribers: <span class="built_in">make</span>(<span class="keyword">map</span>[subscriber]topicFunc),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个订阅者，订阅全部主题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">Subscribe</span><span class="params">()</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125;&#123;</span><br><span class="line">	<span class="keyword">return</span> p.SubscribeTopic(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个订阅者，订阅过滤器筛选后的主题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">SubscribeTopic</span><span class="params">(topic topicFunc)</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, p.buffer)</span><br><span class="line">	p.m.Lock()</span><br><span class="line">	p.subscribers[ch] = topic</span><br><span class="line">	p.m.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出订阅</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">Exit</span><span class="params">(sub <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	p.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">delete</span>(p.subscribers, sub)</span><br><span class="line">	<span class="built_in">close</span>(sub)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布一个主题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">Publish</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	p.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> sub, topic := <span class="keyword">range</span> p.subscribers &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> p.sendTopic(sub, topic, v, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭发布者对象，同时关闭所有订阅者对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> sub := <span class="keyword">range</span> p.subscribers &#123;</span><br><span class="line">		<span class="built_in">delete</span>(p.subscribers, sub)</span><br><span class="line">		<span class="built_in">close</span>(sub)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送主题， 可以容忍一定超时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">sendTopic</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	sub subscriber, topic topicFunc, v <span class="keyword">interface</span>&#123;&#125;, wg *sync.WaitGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">if</span> topic != <span class="literal">nil</span> &amp;&amp; !topic(v) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> sub &lt;- v:</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(p.timeout):</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := NewPublisher(<span class="number">100</span> * time.Millisecond, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">defer</span> p.Close()</span><br><span class="line"></span><br><span class="line">	all := p.Subscribe()</span><br><span class="line">	golang := p.SubscribeTopic(<span class="function"><span class="keyword">func</span> <span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> s, ok := v.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> strings.Contains(s, <span class="string">"golang"</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	p.Publish(<span class="string">"hello, world"</span>)</span><br><span class="line">	p.Publish(<span class="string">"hello, golang"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> msg := <span class="keyword">range</span> all &#123;</span><br><span class="line">			fmt.Println(<span class="string">"all:"</span>, msg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> msg := <span class="keyword">range</span> golang &#123;</span><br><span class="line">			fmt.Println(<span class="string">"golang:"</span>, msg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><h4 id="基于select实现管道的超时判断"><a href="#基于select实现管道的超时判断" class="headerlink" title="基于select实现管道的超时判断"></a>基于select实现管道的超时判断</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> v := &lt;- in :</span><br><span class="line">	  fmt.Println(v)</span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">  	<span class="keyword">return</span> <span class="comment">//超时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于select的default分支实现非阻塞的管道发送或接收操作"><a href="#基于select的default分支实现非阻塞的管道发送或接收操作" class="headerlink" title="基于select的default分支实现非阻塞的管道发送或接收操作"></a>基于select的default分支实现非阻塞的管道发送或接收操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> v := &lt;-in :</span><br><span class="line">	  fmt.Println(v)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	<span class="comment">//无数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过select来阻止main退出"><a href="#通过select来阻止main退出" class="headerlink" title="通过select来阻止main退出"></a>通过select来阻止main退出</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于select来实现随机数"><a href="#基于select来实现随机数" class="headerlink" title="基于select来实现随机数"></a>基于select来实现随机数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> ch &lt;- <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">case</span> ch &lt;- <span class="number">1</span>:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于select实现goroutine的退出"><a href="#基于select实现goroutine的退出" class="headerlink" title="基于select实现goroutine的退出"></a>基于select实现goroutine的退出</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(<span class="built_in">close</span> <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span>  &lt;- <span class="built_in">close</span>:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(c)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于select实现goroutine退出-V2"><a href="#基于select实现goroutine退出-V2" class="headerlink" title="基于select实现goroutine退出 V2"></a>基于select实现goroutine退出 V2</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(<span class="built_in">close</span> <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span>  &lt;- <span class="built_in">close</span>:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> worker(c)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于管道的接收和发送是一一对应的，如果要停止多个goroutine那么需要创建同样数量的管道，性能差，所以可以通过一个管道来实现广播的操作。</p>
<h4 id="基于select实现goroutine退出-V3"><a href="#基于select实现goroutine退出-V3" class="headerlink" title="基于select实现goroutine退出 V3"></a>基于select实现goroutine退出 V3</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wg *sync.WaitGroup, <span class="built_in">close</span> <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span>  &lt;- <span class="built_in">close</span>:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> worker(wg, c)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当每个goroutine收到退出指令时，一般会进行一定的清理工作，但是退出清理的工作无法保证一定完成，因为main线程没有等待各个goroutine工作完成的机制，所以结合sync.WaitGroup增强代码的健壮性</p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ct context.Context, wg *sync.WaitGroup)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="number">123</span>)</span><br><span class="line">			<span class="keyword">case</span> &lt;-ct.Done():</span><br><span class="line">				<span class="keyword">return</span> ct.Err()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">	ct, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> worker(ct, wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	cancel()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><h3 id="错误处理策略"><a href="#错误处理策略" class="headerlink" title="错误处理策略"></a>错误处理策略</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"%v"</span>, p)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获异常不是最终目的，如果异常不可预测，直接输出异常信息是最好的处理方式。</p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><h3 id="RPC基本示例"><a href="#RPC基本示例" class="headerlink" title="RPC基本示例"></a>RPC基本示例</h3><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">	<span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *HelloService)</span> <span class="title">Hello</span><span class="params">(name <span class="keyword">string</span>,reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	*reply = <span class="string">"hello"</span> + name</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rpc.RegisterName(<span class="string">"HelloService"</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":6062"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	conn,err := listener.Accept()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"listening"</span>)</span><br><span class="line">	rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn,err := rpc.Dial(<span class="string">"tcp"</span>,<span class="string">":6062"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">	err = conn.Call(<span class="string">"HelloService.Hello"</span>,<span class="string">"world"</span>, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%v"</span>,reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深入了解RPC"><a href="#深入了解RPC" class="headerlink" title="深入了解RPC"></a>深入了解RPC</h3><h4 id="客户端rpc实现原理"><a href="#客户端rpc实现原理" class="headerlink" title="客户端rpc实现原理"></a>客户端rpc实现原理</h4><h5 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">通常我们在客户端调用rpc框架中的call方法进行同步阻塞调用</span></span><br><span class="line"><span class="comment">该方法首先通过client.Go方法进行了一次异步调用,返回一个表名这次调用的Call结构体。</span></span><br><span class="line"><span class="comment">然后等待Call结构体的Done</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">Call</span><span class="params">(serviceMethod <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	call := &lt;-client.Go(serviceMethod, args, reply, <span class="built_in">make</span>(<span class="keyword">chan</span> *Call, <span class="number">1</span>)).Done</span><br><span class="line">	<span class="keyword">return</span> call.Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">首先构造了一个表示当前调用的call变量</span></span><br><span class="line"><span class="comment">然后通过client.send方法将call的完整参数发送到rpc框架，send方法是线程安全的</span></span><br><span class="line"><span class="comment">当调用完成或者发生错误时，将调用call.done()方法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">Go</span><span class="params">(serviceMethod <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;, done <span class="keyword">chan</span> *Call)</span> *<span class="title">Call</span></span> &#123;</span><br><span class="line">	call := <span class="built_in">new</span>(Call)</span><br><span class="line">	call.ServiceMethod = serviceMethod</span><br><span class="line">	call.Args = args</span><br><span class="line">	call.Reply = reply</span><br><span class="line">	<span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">		done = <span class="built_in">make</span>(<span class="keyword">chan</span> *Call, <span class="number">10</span>) <span class="comment">// buffered.</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// If caller passes done != nil, it must arrange that</span></span><br><span class="line">		<span class="comment">// done has enough buffer for the number of simultaneous</span></span><br><span class="line">		<span class="comment">// RPCs that will be using that channel. If the channel</span></span><br><span class="line">		<span class="comment">// is totally unbuffered, it's best not to run at all.</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">cap</span>(done) == <span class="number">0</span> &#123;</span><br><span class="line">			log.Panic(<span class="string">"rpc: done channel is unbuffered"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	call.Done = done</span><br><span class="line">	client.send(call)</span><br><span class="line">	<span class="keyword">return</span> call</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(call *Call)</span> <span class="title">done</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> call.Done &lt;- call:</span><br><span class="line">		<span class="comment">// ok</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// We don't want to block here. It is the caller's responsibility to make</span></span><br><span class="line">		<span class="comment">// sure the channel has enough buffer space. See comment in Go().</span></span><br><span class="line">		<span class="keyword">if</span> debugLog &#123;</span><br><span class="line">			log.Println(<span class="string">"rpc: discarding Call reply due to insufficient Done chan capacity"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><blockquote>
<p>Protobuf作为接口规范的描述语言，可以作为设计安全的跨语言RPC接口的基础工具</p>
</blockquote>
<h3 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h3><blockquote>
<p>如果从Protobuf的角度看，gRPC只不过是一个针对service接口生成代码的生成器</p>
</blockquote>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">message String &#123;</span><br><span class="line">    string value = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service HelloService &#123;</span><br><span class="line">    rpc Hello(String) returns (String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=. --go_out=plugins=grpc:. hello.proto</span><br></pre></td></tr></table></figure>
<p>生成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHelloServiceServer</span><span class="params">(s *grpc.Server, srv HelloServiceServer)</span></span> &#123;</span><br><span class="line">	s.RegisterService(&amp;_HelloService_serviceDesc, srv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHelloServiceClient</span><span class="params">(cc grpc.ClientConnInterface)</span> <span class="title">HelloServiceClient</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;helloServiceClient&#123;cc&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HelloServiceServer is the server API for HelloService service.</span></span><br><span class="line"><span class="keyword">type</span> HelloServiceServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello(context.Context, *String) (*String, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HelloServiceClient is the client API for HelloService service.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.</span></span><br><span class="line"><span class="keyword">type</span> HelloServiceClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello(ctx context.Context, in *String, opts ...grpc.CallOption) (*String, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重写HelloService服务端"><a href="#重写HelloService服务端" class="headerlink" title="重写HelloService服务端"></a>重写HelloService服务端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	hello <span class="string">"code.yuhaos.com/studygo/grpc/protobuf"</span></span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloService)</span> <span class="title">Hello</span><span class="params">(ctx context.Context, name *hello.String)</span> <span class="params">(*hello.String, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ret hello.String</span><br><span class="line">	ret.Value = <span class="string">"hello"</span> + name.Value</span><br><span class="line">	<span class="keyword">return</span> &amp;ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	grpcServer := grpc.NewServer()</span><br><span class="line">	hello.RegisterHelloServiceServer(grpcServer, <span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	grpcServer.Serve(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重写HelloService客户端"><a href="#重写HelloService客户端" class="headerlink" title="重写HelloService客户端"></a>重写HelloService客户端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	hello <span class="string">"code.yuhaos.com/studygo/grpc/protobuf"</span></span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := grpc.Dial(<span class="string">":1234"</span>,grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	client := hello.NewHelloServiceClient(conn)</span><br><span class="line">	res, err := client.Hello(context.Background(), &amp;hello.String&#123;Value:<span class="string">"world"</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(res.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gRPC流"><a href="#gRPC流" class="headerlink" title="gRPC流"></a>gRPC流</h3><blockquote>
<p>RPC是远程调用，因此每次调用的函数参数和返回值不能太大，否则将严重影响每次调用的响应时间，因此传统的RPC方法调用对于上传和下载大数据量的场景并不合适，为此gRPC框架针对服务器和客户端分别提供了流特性</p>
</blockquote>
<h4 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">message String &#123;</span><br><span class="line">    string value = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service HelloService &#123;</span><br><span class="line">    rpc Hello(String) returns (String);</span><br><span class="line">    rpc Channel (stream String) returns (stream String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">HelloSerivceServer和HelloServiceClient两个接口都添加了Channel方法的定义</span></span><br><span class="line"><span class="comment">该方法可以用于客户端和服务端的双向通信</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">type</span> HelloServiceServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello(context.Context, *String) (*String, error)</span><br><span class="line">	Channel(HelloService_ChannelServer) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloServiceClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello(ctx context.Context, in *String, opts ...grpc.CallOption) (*String, error)</span><br><span class="line">	Channel(ctx context.Context, opts ...grpc.CallOption) (HelloService_ChannelClient, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">HelloService_ChannelServer和HelloService_ChannelClient都为接口</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService_ChannelServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*String) error</span><br><span class="line">	Recv() (*String, error)</span><br><span class="line">	grpc.ServerStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService_ChannelClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*String) error</span><br><span class="line">	Recv() (*String, error)</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于流的Server"><a href="#基于流的Server" class="headerlink" title="基于流的Server"></a>基于流的Server</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	hello <span class="string">"code.yuhaos.com/studygo/grpc/protobuf"</span></span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloService)</span> <span class="title">Hello</span><span class="params">(ctx context.Context, name *hello.String)</span> <span class="params">(*hello.String, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ret hello.String</span><br><span class="line">	ret.Value = <span class="string">"hello"</span> + name.Value</span><br><span class="line">	<span class="keyword">return</span> &amp;ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloService)</span> <span class="title">Channel</span><span class="params">(stream hello.HelloService_ChannelServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		args, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		reply := &amp;hello.String&#123;Value:<span class="string">"Hello"</span> + args.GetValue()&#125;</span><br><span class="line">		err = stream.Send(reply)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	grpcServer := grpc.NewServer()</span><br><span class="line">	hello.RegisterHelloServiceServer(grpcServer, <span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	grpcServer.Serve(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于流的client"><a href="#基于流的client" class="headerlink" title="基于流的client"></a>基于流的client</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	hello <span class="string">"code.yuhaos.com/studygo/grpc/protobuf"</span></span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := grpc.Dial(<span class="string">":1234"</span>,grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	client := hello.NewHelloServiceClient(conn)</span><br><span class="line">	stream, err := client.Channel(context.Background())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := stream.Send(&amp;hello.String&#123;Value:<span class="string">"hi"</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(err)</span><br><span class="line">			&#125;</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		res, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Println(res.GetValue())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于docker的pub-sub与grpc流实现发布订阅模型"><a href="#基于docker的pub-sub与grpc流实现发布订阅模型" class="headerlink" title="基于docker的pub/sub与grpc流实现发布订阅模型"></a>基于docker的pub/sub与grpc流实现发布订阅模型</h3><h4 id="protobuf-1"><a href="#protobuf-1" class="headerlink" title="protobuf"></a>protobuf</h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package pub_sub_service;</span><br><span class="line"></span><br><span class="line">message String &#123;</span><br><span class="line">    string value=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service PubsubService &#123;</span><br><span class="line">    rpc Publish(String) returns (String);</span><br><span class="line">    rpc Subscribe(String) returns (stream String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	pub_sub_service <span class="string">"code.yuhaos.com/studygo/grpc-pub-sub/protobuf"</span></span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"github.com/docker/docker/pkg/pubsub"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PubsubService <span class="keyword">struct</span> &#123;</span><br><span class="line">	pub *pubsub.Publisher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPubSubService</span><span class="params">()</span> *<span class="title">PubsubService</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;PubsubService&#123;</span><br><span class="line">		pub:pubsub.NewPublisher(<span class="number">100</span>*time.Millisecond, <span class="number">10</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PubsubService)</span> <span class="title">Publish</span><span class="params">(ctx context.Context, arg *pub_sub_service.String)</span> <span class="params">(*pub_sub_service.String, error)</span></span>&#123;</span><br><span class="line">	p.pub.Publish(arg.GetValue())</span><br><span class="line">	<span class="keyword">return</span> &amp;pub_sub_service.String&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PubsubService)</span> <span class="title">Subscribe</span><span class="params">(arg *pub_sub_service.String, stream pub_sub_service.PubsubService_SubscribeServer)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">	ch := p.pub.SubscribeTopic(<span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> key, ok := v.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> strings.HasPrefix(key, arg.GetValue()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		<span class="keyword">if</span> err := stream.Send(&amp;pub_sub_service.String&#123;Value:v.(<span class="keyword">string</span>)&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	grpcServer := grpc.NewServer()</span><br><span class="line"></span><br><span class="line">	pub_sub_service.RegisterPubsubServiceServer(grpcServer, NewPubSubService())</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1235"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	grpcServer.Serve(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="client-pub"><a href="#client-pub" class="headerlink" title="client_pub"></a>client_pub</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	pub_sub_service <span class="string">"code.yuhaos.com/studygo/grpc-pub-sub/protobuf"</span></span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := grpc.Dial(<span class="string">"localhost:1235"</span>, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	client := pub_sub_service.NewPubsubServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	_, err = client.Publish(context.Background(), &amp;pub_sub_service.String&#123;Value:<span class="string">"golang:hello go"</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = client.Publish(context.Background(), &amp;pub_sub_service.String&#123;Value:<span class="string">"php:hello php"</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="client-sub"><a href="#client-sub" class="headerlink" title="client_sub"></a>client_sub</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	pub_sub_service <span class="string">"code.yuhaos.com/studygo/grpc-pub-sub/protobuf"</span></span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := grpc.Dial(<span class="string">":1235"</span>, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	client := pub_sub_service.NewPubsubServiceClient(conn)</span><br><span class="line">	stream, err := client.Subscribe(context.Background(), &amp;pub_sub_service.String&#123;Value:<span class="string">"go"</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		reply, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">"err"</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"reply:%v"</span>, reply.GetValue())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GO-WEB"><a href="#GO-WEB" class="headerlink" title="GO-WEB"></a>GO-WEB</h2><h3 id="httprouter"><a href="#httprouter" class="headerlink" title="httprouter"></a>httprouter</h3><h4 id="路由冲突"><a href="#路由冲突" class="headerlink" title="路由冲突"></a>路由冲突</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conflict:</span><br><span class="line">GET /user/info/:name</span><br><span class="line">GET /user/:id</span><br><span class="line"></span><br><span class="line">no conflict:</span><br><span class="line">GET  /user/info/:name</span><br><span class="line">POST /user/:id</span><br></pre></td></tr></table></figure>
<p>因为httprouter使用的是显示匹配，所以在设计路由时需要规避一些会导致路由冲突的情况</p>
<p>如果两个路由拥有一致的http方法和请求路径前缀，切在某个位置出现了A路由是wildcard(:id)参数，B路由是普通字符串那么就会发生路由冲突</p>
<h4 id="对特殊情况进行定制"><a href="#对特殊情况进行定制" class="headerlink" title="对特殊情况进行定制"></a>对特殊情况进行定制</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/julienschmidt/httprouter"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := httprouter.New()</span><br><span class="line"></span><br><span class="line">	r.NotFound = http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">"404"</span>))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.PanicHandler = <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request, i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		writer.Write([]<span class="keyword">byte</span>(<span class="string">"500"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">":8081"</span>, r)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Httprouter和众多衍生router使用的数据结构被称为压缩字典树。</p>
<p>发生路由冲突的情况也是由于构建压缩字典树时造成的。</p>
<p><img src="/2020/07/01/Go语言核心编程读书笔记/Users/yuhao.su/Library/Application Support/typora-user-images/image-20200701160954287.png" alt="image-20200701160954287"></p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/sirupsen/logrus"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LogMiddleware</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span> <span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">		logrus.Println(<span class="string">"test"</span>)</span><br><span class="line">		next.ServeHTTP(w, r)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	w.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	http.Handle(<span class="string">"/test"</span>, LogMiddleware(http.HandlerFunc(Hello)))</span><br><span class="line">	</span><br><span class="line">	http.ListenAndServe(<span class="string">":8081"</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中间件的原理"><a href="#中间件的原理" class="headerlink" title="中间件的原理"></a>中间件的原理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中间件的原理在于http.handle方法中需要传入Handler参数</span></span><br><span class="line"><span class="comment">//handler为一个接口，既只要实现了ServeHTTP方法的即为Handler</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HandlerFunc可以将普通的方法强转为Handler类型</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="更优雅的使用中间件"><a href="#更优雅的使用中间件" class="headerlink" title="更优雅的使用中间件"></a>更优雅的使用中间件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/sirupsen/logrus"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> middleware <span class="function"><span class="keyword">func</span><span class="params">(http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">Router</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">	middlewareChain [] middleware</span><br><span class="line">	mux <span class="keyword">map</span>[<span class="keyword">string</span>] http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">()</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Router&#123;</span><br><span class="line">		middlewareChain:[]middleware&#123;&#125;,</span><br><span class="line">		mux: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>] http.Handler),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">Use</span><span class="params">(m middleware)</span></span> &#123;</span><br><span class="line">	r.middlewareChain = <span class="built_in">append</span>(r.middlewareChain, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">Add</span><span class="params">(route <span class="keyword">string</span>, h http.Handler)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mergeHandler = h</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(r.middlewareChain)<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">		mergeHandler = r.middlewareChain[i](mergeHandler)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.mux[route] = mergeHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">ServeHTTP</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LogMiddleware</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span> <span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">		logrus.Println(<span class="string">"test"</span>)</span><br><span class="line">		next.ServeHTTP(w, r)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	w.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	r := NewRouter()</span><br><span class="line">	r.Use(LogMiddleware)</span><br><span class="line">	r.Add(<span class="string">"/test"</span>, http.HandlerFunc(Hello))</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">":8081"</span>, r)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务流量限制"><a href="#服务流量限制" class="headerlink" title="服务流量限制"></a>服务流量限制</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有些程序偏网络IO瓶颈，例如CDN服务，Proxy服务</p>
<p>有些程序偏CPU/GPU瓶颈，例如登录校验服务，图像处理服务</p>
<p>有些程序偏磁盘，例如存储系统，数据库</p>
<p>对于IO/Network瓶颈类的程序，其表现是网课/磁盘IO会先于CPU打满，这种情况即使优化CPU的使用也无法提高整个系统的吞吐量，只有提高磁盘的读写速度，增加内存大小，提升网卡带宽来提升整体性能</p>
<h3 id="漏桶限流"><a href="#漏桶限流" class="headerlink" title="漏桶限流"></a>漏桶限流</h3><blockquote>
<p>我们有一个，每过一段时间，向外漏一滴水，如果你接到了这滴水，那么就可以继续服务请求，否则需要等待下一滴水</p>
</blockquote>
<h3 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h3><blockquote>
<p>匀速向桶中添加令牌，服务请求时需要从桶中获取令牌，令牌的数目可以按照需要消耗的资源进行相应的调整，如果没有令牌，可以选择等待或者放弃。该模型支持并发。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">令牌桶模拟</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> fillInterval = time.Millisecond * <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> capacity = <span class="number">100</span></span><br><span class="line">	<span class="keyword">var</span> tokenBucket = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, capacity)</span><br><span class="line"></span><br><span class="line">	fillToken := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ticker := time.NewTicker(fillInterval)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> tokenBucket &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">					<span class="keyword">default</span>:</span><br><span class="line">					&#125;</span><br><span class="line">					fmt.Println(<span class="string">"current token cnt:"</span>, <span class="built_in">len</span>(tokenBucket), time.Now())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> fillToken()</span><br><span class="line">	time.Sleep(time.Hour)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">模拟取令牌</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">TakeAvailable := <span class="function"><span class="keyword">func</span><span class="params">(block <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> takenResult <span class="keyword">bool</span></span><br><span class="line">		<span class="keyword">if</span> block &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-tokenBucket:</span><br><span class="line">				takenResult = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;- tokenBucket:</span><br><span class="line">				takenResult = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				takenResult = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法是一般令牌桶的实现，下面是优化算法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">思考一下，令牌桶每隔一段固定时间向桶中放令牌，我们记下上一次放令牌的时间为t1和当时的令牌数为k1,放令牌的间隔时间为ti，每次向桶中放x个令牌，令牌容量为cap。现在如果有人来获取令牌时间为t2，在t2时刻应该存在的令牌为多少呢？</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">cur = k1 + ((t2-t1)/ti)*x</span><br><span class="line">cur = cur &gt; <span class="built_in">cap</span> ? <span class="built_in">cap</span> : cur</span><br></pre></td></tr></table></figure>
<p>通过这种方式，只需要在取令牌的时候去获取令牌数量，在得到正确的令牌数之后，再进行实际的take即可。</p>
<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><h3 id="分布式ID-雪花算法"><a href="#分布式ID-雪花算法" class="headerlink" title="分布式ID-雪花算法"></a>分布式ID-雪花算法</h3><p><img src="/2020/07/01/Go语言核心编程读书笔记/Users/yuhao.su/Library/Application Support/typora-user-images/image-20200702163347976.png" alt="image-20200702163347976"></p>
<p>首先确定数值是64位，将其划分为4个部分，不含开头的第一个bit，这个bit是符号位</p>
<p>第一部分，用41位来代表收到请求的时间戳，单位为毫秒</p>
<p>第二部分，用5位来表示数据中心id</p>
<p>第三部分，用5位来表示机器实例id</p>
<p>第四部分，用12位的循环自增id</p>
<p>这样一台机器，同一毫秒可以生产 2 ^ 12 = 4096条消息，一秒409.6万条</p>
<p>数据中心加上实例id共10位，可以支持我们每个数据中心部署32台机器，所有数据中心1024台实例</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="redis-setnx"><a href="#redis-setnx" class="headerlink" title="redis setnx"></a>redis setnx</h4><h4 id="基于zooKeeper"><a href="#基于zooKeeper" class="headerlink" title="基于zooKeeper"></a>基于zooKeeper</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c, _, err := zk.Connect([]<span class="keyword">string</span>&#123;<span class="string">"127.0.0.1"</span>&#125;, time.Second)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  l := zk.NewLock(c, <span class="string">"/lock"</span>, zk.WorldACL(zk.PermAll))</span><br><span class="line">  err = l.Lock()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//lock succ</span></span><br><span class="line">  </span><br><span class="line">  l.Unlock()</span><br><span class="line">  <span class="comment">//unlock succ</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于zooKeeper的锁与基于redis的锁的不同之处在于Lock成功之前会一直阻塞</p>
<p>该种方式的原理是基于临时的Sequence节点和Watch API。</p>
<p>比如使用了/lock节点，Lock会在该节点下的节点列表中插入自己的值，只要节点下的子节点发生变化，就会通知所有watch该节点的程序。这时候程序会检查当前节点下最小的子节点的id是否与自己的一致。如果一致说明加锁成功了。</p>
<p>这种分布式的阻塞锁比较适合分布式的任务调度场景，但不适合高频次的持锁时间短的抢锁场景。</p>
<p>Google的Chubby论文里的阐述，基于强一致协议的锁适用于粗粒度的加锁操作。这里的粗粒度指锁的占用时间长。</p>
<h4 id="基于etcd"><a href="#基于etcd" class="headerlink" title="基于etcd"></a>基于etcd</h4><h3 id="延时任务系统"><a href="#延时任务系统" class="headerlink" title="延时任务系统"></a>延时任务系统</h3><h4 id="时间堆"><a href="#时间堆" class="headerlink" title="时间堆"></a>时间堆</h4><h5 id="小顶堆"><a href="#小顶堆" class="headerlink" title="小顶堆"></a>小顶堆</h5><p>小顶堆就是一种特殊的二叉树，对于定时器来讲，如果堆顶的元素比当前时间还大，说明堆内的所有元素都比当前时间打</p>
<h4 id="四叉堆"><a href="#四叉堆" class="headerlink" title="四叉堆"></a>四叉堆</h4><p>Go内置的定时器利用了四叉堆</p>
<p><img src="/2020/07/01/Go语言核心编程读书笔记/Users/yuhao.su/Library/Application Support/typora-user-images/image-20200702175744308.png" alt="image-20200702175744308"></p>
<h4 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h4><p>用时间轮来实现定时器时，我们需要定义每一个格子的刻度，中心有秒针顺时针转动。每转动到一个刻度时，我们就需要去查看该刻度挂载的任务列表是否有已到期的任务。</p>
<h4 id="任务分发"><a href="#任务分发" class="headerlink" title="任务分发"></a>任务分发</h4><p>每一个实例，每个小时就去数据库里把下一个小时需要处理的任务捞出来。</p>
<p>可以通过：</p>
<ol>
<li>将任务触发的信息封装为一条消息，发送到消息队列，由用户对消息队列进行监听。</li>
<li>对用户预先配置的回调函数进行调用。</li>
</ol>
<h4 id="数据再平衡"><a href="#数据再平衡" class="headerlink" title="数据再平衡"></a>数据再平衡</h4><p>当一台实例出现故障时，我们可以通过类似es的方式将数据同步到副本节点以保证数据再平衡。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="基于洗牌算法的负载均衡"><a href="#基于洗牌算法的负载均衡" class="headerlink" title="基于洗牌算法的负载均衡"></a>基于洗牌算法的负载均衡</h3><blockquote>
<p>设计y一个大小和节点数组一致的索引素组，每次新的请求来的时候，我们对索引数组洗牌，然后取第一个元素作为选中的服务节点，如果请求失败，选择下一个节点重试。</p>
</blockquote>
<h4 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> endpoints = []<span class="keyword">string</span> &#123;</span><br><span class="line">  	<span class="string">"xxx.xxx.xxx.x:1"</span>,</span><br><span class="line">    <span class="string">"xxx.xxx.xxx.x:2"</span>,</span><br><span class="line">    <span class="string">"xxx.xxx.xxx.x:3"</span>,</span><br><span class="line">    <span class="string">"xxx.xxx.xxx.x:4"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shuffle</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">    a := rand.Intn(<span class="built_in">len</span>(slice))</span><br><span class="line">    b := rand.Intn(<span class="built_in">len</span>(slice))</span><br><span class="line">    slice[a], slice[b] = slice[b], slice[a]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法2（更均衡）"><a href="#算法2（更均衡）" class="headerlink" title="算法2（更均衡）"></a>算法2（更均衡）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shuffle</span><span class="params">(indexs []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="built_in">len</span>(indexs); i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line">    lastIdx := i<span class="number">-1</span></span><br><span class="line">    idx := rand.Int(i)</span><br><span class="line">    indexs[lastIdx], indexs[idx] = indexs[idx], indexs[lastIdx]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法2简化"><a href="#算法2简化" class="headerlink" title="算法2简化"></a>算法2简化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shuffle</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  b := rand.Perm(n)</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分布式配置管理"><a href="#分布式配置管理" class="headerlink" title="分布式配置管理"></a>分布式配置管理</h2><h4 id="基于etcd实现"><a href="#基于etcd实现" class="headerlink" title="基于etcd实现"></a>基于etcd实现</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>开箱即用</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>不利于管理，无法承载高qps</p>
<h2 id="Go语言中使用时的坑"><a href="#Go语言中使用时的坑" class="headerlink" title="Go语言中使用时的坑"></a>Go语言中使用时的坑</h2><h3 id="可变参数是空接口类型"><a href="#可变参数是空接口类型" class="headerlink" title="可变参数是空接口类型"></a>可变参数是空接口类型</h3><p>当参数的可变参数是空接口类型时，传入空参数的切片时需要注意参数展开的问题</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a = []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">  fmt.Println(a) <span class="comment">// [1,2,3]</span></span><br><span class="line">  fmt.Println(a...) <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组是值传递"><a href="#数组是值传递" class="headerlink" title="数组是值传递"></a>数组是值传递</h3><p>在函数调用的过程中，数组是值传递</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(arr [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">			arr[i] = arr[i]*<span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(x)</span><br><span class="line"></span><br><span class="line">	fmt.Println(x) <span class="comment">//1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="map遍历是顺序不固定的"><a href="#map遍历是顺序不固定的" class="headerlink" title="map遍历是顺序不固定的"></a>map遍历是顺序不固定的</h4><p>map是一种hash表实现，每次遍历的顺序都可能不一样</p>
<h3 id="recover必须在defer函数中运行"><a href="#recover必须在defer函数中运行" class="headerlink" title="recover必须在defer函数中运行"></a>recover必须在defer函数中运行</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">recover</span>()</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"recover test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="独占cpu导致其他的goroutine饿死"><a href="#独占cpu导致其他的goroutine饿死" class="headerlink" title="独占cpu导致其他的goroutine饿死"></a>独占cpu导致其他的goroutine饿死</h3><p>Goroutine是协作式抢占调度，Goroutine本身不会主动放弃CPU:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> &#123;&#125; <span class="comment">//占用cpu</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方案1：利用runtime.Gosched()</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    runtime.Gosched()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方案2: 通过阻塞方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不同的goroutine之间不满足顺序一致性内存模型"><a href="#不同的goroutine之间不满足顺序一致性内存模型" class="headerlink" title="不同的goroutine之间不满足顺序一致性内存模型"></a>不同的goroutine之间不满足顺序一致性内存模型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	msg = <span class="string">"hello"</span></span><br><span class="line">	done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	<span class="keyword">for</span> !done &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该程序中，对于main来说msg=”hello”和done=true的执行顺序是不确定的，所以可能无法输出hello，做以下修改保证了一致性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	msg = <span class="string">"hello"</span></span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	&lt;-done</span><br><span class="line"></span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包错误引用同一个变量"><a href="#闭包错误引用同一个变量" class="headerlink" title="闭包错误引用同一个变量"></a>闭包错误引用同一个变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(i)</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5 5 5 5 5</span></span><br></pre></td></tr></table></figure>
<p>修正后</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每轮迭代中生成一个局部变量通过参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(i)</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在循环内部执行defer语句"><a href="#在循环内部执行defer语句" class="headerlink" title="在循环内部执行defer语句"></a>在循环内部执行defer语句</h3><p>defer在循环退出时才能执行，在for执行defer会导致资源延迟释放</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">'/path/to/file'</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过在for中构造一个局部函数，在局部函数内部defer</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      f, err := os.Open(<span class="string">'/path/to/file'</span>)</span><br><span class="line">    	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      	log.Fatal(err)</span><br><span class="line">	    &#125;</span><br><span class="line">    	<span class="keyword">defer</span> f.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片会导致整个底层数组被锁定"><a href="#切片会导致整个底层数组被锁定" class="headerlink" title="切片会导致整个底层数组被锁定"></a>切片会导致整个底层数组被锁定</h3><p>切片会导致整个底层数组被锁定，底层数组无法释放内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  headerMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ &#123;</span><br><span class="line">    name := <span class="string">"/path/to/file"</span></span><br><span class="line">    data, err := ioutil.ReadFile(name)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    headerMap[name]  = data[:<span class="number">1</span>] <span class="comment">//导致底层数组被锁定</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化，将结果克隆一份</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">headerMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ &#123;</span><br><span class="line">    name := <span class="string">"/path/to/file"</span></span><br><span class="line">    data, err := ioutil.ReadFile(name)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    headerMap[name] = <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;&#125;, data[:<span class="number">1</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-07-01</span><i class="fa fa-tag"></i><a class="tag" href="/tags/go/" title="go">go </a></div></div></div></div><!--.share--><!--  .weibo  a.fa.fa-weibo(href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&title=',e(d.title),'&appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));")
.weixin
  a.fa.fa-weixin(href=url_for("http://twitter.com/home?status="+","+config.url+"/"+page.path+","+config.title+","+page.title+",;"))--><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/07/14/高性能Mysq读书笔记/" title="高性能Mysq读书笔记">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/01/01/2020读书计划/" title="2020读书计划">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>